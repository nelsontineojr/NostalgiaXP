{"ast":null,"code":"var _jsxFileName = \"/Users/maguito/Desktop/Content/Coding/winXP-nostalgia/src/WinXP/apps/Minesweeper/index.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView';\n\n// state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction getInitState() {\n  let difficulty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Beginner';\n  return {\n    difficulty,\n    status: 'new',\n    ...genGameConfig(Config[difficulty])\n  };\n}\nfunction reducer(state) {\n  let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      const difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n    case 'START_GAME':\n      const exclude = action.payload;\n      return {\n        ...state,\n        ...insertMines({\n          ...Config[state.difficulty],\n          exclude\n        }, state.ceils),\n        status: 'started'\n      };\n    case 'OPEN_CEIL':\n      {\n        const indexes = autoCeils(state, action.payload);\n        const ceils = [...state.ceils];\n        indexes.forEach(i => {\n          const ceil = ceils[i];\n          ceils[i] = {\n            ...ceil,\n            state: 'open'\n          };\n        });\n        return {\n          ...state,\n          ceils\n        };\n      }\n    case 'CHANGE_CEIL_STATE':\n      {\n        const index = action.payload;\n        const ceils = [...state.ceils];\n        const ceil = state.ceils[index];\n        let newState;\n        switch (ceil.state) {\n          case 'cover':\n            newState = 'flag';\n            break;\n          case 'flag':\n            newState = 'unknown';\n            break;\n          case 'unknown':\n            newState = 'cover';\n            break;\n          default:\n            throw new Error(`Unknown ceil state ${ceil.state}`);\n        }\n        ceils[index] = {\n          ...ceil,\n          state: newState\n        };\n        return {\n          ...state,\n          ceils\n        };\n      }\n    case 'GAME_OVER':\n      {\n        const ceils = state.ceils.map(ceil => {\n          if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n            return {\n              ...ceil,\n              state: 'mine'\n            };\n          } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n            return {\n              ...ceil,\n              state: 'misflagged'\n            };\n          } else {\n            return {\n              ...ceil,\n              opening: false\n            };\n          }\n        });\n        ceils[action.payload].state = 'die';\n        return {\n          ...state,\n          status: 'died',\n          ceils\n        };\n      }\n    case 'WON':\n      {\n        const ceils = state.ceils.map(ceil => {\n          if (ceil.minesAround >= 0) {\n            return {\n              ...ceil,\n              state: 'open'\n            };\n          } else {\n            return {\n              ...ceil,\n              state: 'flag'\n            };\n          }\n        });\n        return {\n          ...state,\n          status: 'won',\n          ceils\n        };\n      }\n    case 'OPENING_CEIL':\n      {\n        const ceil = state.ceils[action.payload];\n        const ceils = state.ceils.map(ceil => ({\n          ...ceil,\n          opening: false\n        }));\n        ceils[action.payload] = {\n          ...ceil,\n          opening: true\n        };\n        return {\n          ...state,\n          ceils\n        };\n      }\n    case 'OPENING_CEILS':\n      {\n        const indexes = getNearIndexes(action.payload, state.rows, state.columns);\n        const ceils = state.ceils.map(ceil => ({\n          ...ceil,\n          opening: false\n        }));\n        [...indexes, action.payload].forEach(index => {\n          const ceil = {\n            ...ceils[index]\n          };\n          ceil.opening = true;\n          ceils[index] = ceil;\n        });\n        return {\n          ...state,\n          ceils\n        };\n      }\n    default:\n      return state;\n  }\n}\nfunction MineSweeper(_ref) {\n  _s();\n  let {\n    defaultDifficulty,\n    onClose\n  } = _ref;\n  const [state, dispatch] = useReducer(reducer, getInitState(defaultDifficulty));\n  const seconds = useTimer(state.status);\n  function changeCeilState(index) {\n    const ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({\n      type: 'CHANGE_CEIL_STATE',\n      payload: index\n    });\n  }\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({\n          type: 'START_GAME',\n          payload: index\n        });\n        dispatch({\n          type: 'OPEN_CEIL',\n          payload: index\n        });\n        break;\n      case 'started':\n        const ceil = state.ceils[index];\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({\n            type: 'GAME_OVER',\n            payload: index\n          });\n        } else {\n          dispatch({\n            type: 'OPEN_CEIL',\n            payload: index\n          });\n        }\n        break;\n      default:\n      // console.log(state.status);\n    }\n  }\n  function openCeils(index) {\n    const ceil = state.ceils[index];\n    if (ceil.state !== 'open' || ceil.minesAround <= 0 || state.status !== 'started') return;\n    const indexes = getNearIndexes(index, state.rows, state.columns);\n    const nearCeils = indexes.map(i => state.ceils[i]);\n    if (nearCeils.filter(ceil => ceil.state === 'flag').length !== ceil.minesAround) return;\n    const mineIndex = indexes.find(i => state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag');\n    if (mineIndex) {\n      dispatch({\n        type: 'GAME_OVER',\n        payload: mineIndex\n      });\n    } else {\n      indexes.forEach(i => dispatch({\n        type: 'OPEN_CEIL',\n        payload: i\n      }));\n    }\n  }\n  useEffect(() => {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({\n        type: 'WON'\n      });\n    }\n  });\n  function onReset(difficulty) {\n    dispatch({\n      type: 'CLEAR_MAP',\n      payload: difficulty\n    });\n  }\n  function checkRemains() {\n    const safeCeils = state.ceils.filter(ceil => ceil.state !== 'open').filter(ceil => ceil.minesAround >= 0);\n    return safeCeils.length;\n  }\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEIL',\n      payload: index\n    });\n  }\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEILS',\n      payload: index\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(MinesweeperView, {\n    ...state,\n    onClose: onClose,\n    changeCeilState: changeCeilState,\n    openCeil: openCeil,\n    openCeils: openCeils,\n    onReset: onReset,\n    seconds: seconds,\n    openingCeil: openingCeil,\n    openingCeils: openingCeils\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n}\n_s(MineSweeper, \"2+64J9pulBICyo8Uc+tbwYBe/tE=\", false, function () {\n  return [useTimer];\n});\n_c = MineSweeper;\nfunction genGameConfig(config) {\n  const {\n    rows,\n    columns,\n    mines\n  } = config;\n  const ceils = Array(rows * columns).fill().map(_ => ({\n    state: 'cover',\n    minesAround: 0,\n    opening: false\n  }));\n  return {\n    rows,\n    columns,\n    ceils,\n    mines\n  };\n}\nfunction insertMines(config, originCeils) {\n  const {\n    rows,\n    columns,\n    mines,\n    exclude\n  } = config;\n  const ceils = originCeils.map(ceil => ({\n    ...ceil\n  }));\n  if (rows * columns !== ceils.length) throw new Error('rows and columns not equal to ceils');\n  const indexArray = [...Array(rows * columns).keys()];\n  sampleSize(indexArray.filter(i => i !== exclude), mines).forEach(chosen => {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(nearIndex => {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows,\n    columns,\n    ceils,\n    mines\n  };\n}\nfunction autoCeils(state, index) {\n  const {\n    rows,\n    columns\n  } = state;\n  const ceils = state.ceils.map(ceil => ({\n    ...ceil,\n    walked: false\n  }));\n  return walkCeils(index);\n  function walkCeils(index) {\n    const ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [index, ...getNearIndexes(index, rows, columns).reduce((lastIndexes, ceilIndex) => {\n      return [...lastIndexes, ...walkCeils(ceilIndex)];\n    }, [])];\n  }\n}\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  const row = Math.floor(index / columns);\n  const column = index % columns;\n  return [index - columns - 1, index - columns, index - columns + 1, index - 1, index + 1, index + columns - 1, index + columns, index + columns + 1].filter((_, arrayIndex) => {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\nfunction useTimer(status) {\n  _s2();\n  const [seconds, setSeconds] = useState(0);\n  function addSecond() {\n    setSeconds(sec => sec + 1);\n  }\n  useEffect(() => {\n    let timer;\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n      case 'new':\n        setSeconds(0);\n        break;\n      default:\n        break;\n    }\n    return () => clearInterval(timer);\n  }, [status]);\n  return seconds;\n}\n_s2(useTimer, \"mcG2hTHI4q8+uIAAnRxppoT2y1s=\");\nexport default MineSweeper;\nvar _c;\n$RefreshReg$(_c, \"MineSweeper\");","map":{"version":3,"names":["React","useReducer","useEffect","useState","sampleSize","Config","MinesweeperView","jsxDEV","_jsxDEV","getInitState","difficulty","arguments","length","undefined","status","genGameConfig","reducer","state","action","type","payload","exclude","insertMines","ceils","indexes","autoCeils","forEach","i","ceil","index","newState","Error","map","minesAround","opening","getNearIndexes","rows","columns","MineSweeper","_ref","_s","defaultDifficulty","onClose","dispatch","seconds","useTimer","changeCeilState","includes","openCeil","openCeils","nearCeils","filter","mineIndex","find","checkRemains","onReset","safeCeils","openingCeil","openingCeils","fileName","_jsxFileName","lineNumber","columnNumber","_c","config","mines","Array","fill","_","originCeils","indexArray","keys","chosen","nearIndex","walked","walkCeils","reduce","lastIndexes","ceilIndex","row","Math","floor","column","arrayIndex","_s2","setSeconds","addSecond","sec","timer","setInterval","clearInterval","$RefreshReg$"],"sources":["/Users/maguito/Desktop/Content/Coding/winXP-nostalgia/src/WinXP/apps/Minesweeper/index.js"],"sourcesContent":["import React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\n\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView';\n\n// state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\n\nfunction getInitState(difficulty = 'Beginner') {\n  return {\n    difficulty,\n    status: 'new',\n    ...genGameConfig(Config[difficulty]),\n  };\n}\n\nfunction reducer(state, action = {}) {\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      const difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n    case 'START_GAME':\n      const exclude = action.payload;\n      return {\n        ...state,\n        ...insertMines({ ...Config[state.difficulty], exclude }, state.ceils),\n        status: 'started',\n      };\n    case 'OPEN_CEIL': {\n      const indexes = autoCeils(state, action.payload);\n      const ceils = [...state.ceils];\n      indexes.forEach(i => {\n        const ceil = ceils[i];\n        ceils[i] = { ...ceil, state: 'open' };\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'CHANGE_CEIL_STATE': {\n      const index = action.payload;\n      const ceils = [...state.ceils];\n      const ceil = state.ceils[index];\n      let newState;\n      switch (ceil.state) {\n        case 'cover':\n          newState = 'flag';\n          break;\n        case 'flag':\n          newState = 'unknown';\n          break;\n        case 'unknown':\n          newState = 'cover';\n          break;\n        default:\n          throw new Error(`Unknown ceil state ${ceil.state}`);\n      }\n      ceils[index] = { ...ceil, state: newState };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'GAME_OVER': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n          return {\n            ...ceil,\n            state: 'mine',\n          };\n        } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'misflagged',\n          };\n        } else {\n          return {\n            ...ceil,\n            opening: false,\n          };\n        }\n      });\n      ceils[action.payload].state = 'die';\n      return {\n        ...state,\n        status: 'died',\n        ceils,\n      };\n    }\n    case 'WON': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'open',\n          };\n        } else {\n          return {\n            ...ceil,\n            state: 'flag',\n          };\n        }\n      });\n      return {\n        ...state,\n        status: 'won',\n        ceils,\n      };\n    }\n    case 'OPENING_CEIL': {\n      const ceil = state.ceils[action.payload];\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      ceils[action.payload] = { ...ceil, opening: true };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'OPENING_CEILS': {\n      const indexes = getNearIndexes(action.payload, state.rows, state.columns);\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      [...indexes, action.payload].forEach(index => {\n        const ceil = { ...ceils[index] };\n        ceil.opening = true;\n        ceils[index] = ceil;\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nfunction MineSweeper({ defaultDifficulty, onClose }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    getInitState(defaultDifficulty),\n  );\n  const seconds = useTimer(state.status);\n  function changeCeilState(index) {\n    const ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({ type: 'CHANGE_CEIL_STATE', payload: index });\n  }\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({ type: 'START_GAME', payload: index });\n        dispatch({ type: 'OPEN_CEIL', payload: index });\n        break;\n      case 'started':\n        const ceil = state.ceils[index];\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({ type: 'GAME_OVER', payload: index });\n        } else {\n          dispatch({ type: 'OPEN_CEIL', payload: index });\n        }\n        break;\n      default:\n      // console.log(state.status);\n    }\n  }\n  function openCeils(index) {\n    const ceil = state.ceils[index];\n    if (\n      ceil.state !== 'open' ||\n      ceil.minesAround <= 0 ||\n      state.status !== 'started'\n    )\n      return;\n    const indexes = getNearIndexes(index, state.rows, state.columns);\n    const nearCeils = indexes.map(i => state.ceils[i]);\n    if (\n      nearCeils.filter(ceil => ceil.state === 'flag').length !==\n      ceil.minesAround\n    )\n      return;\n    const mineIndex = indexes.find(\n      i => state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag',\n    );\n    if (mineIndex) {\n      dispatch({ type: 'GAME_OVER', payload: mineIndex });\n    } else {\n      indexes.forEach(i => dispatch({ type: 'OPEN_CEIL', payload: i }));\n    }\n  }\n  useEffect(() => {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({ type: 'WON' });\n    }\n  });\n  function onReset(difficulty) {\n    dispatch({ type: 'CLEAR_MAP', payload: difficulty });\n  }\n  function checkRemains() {\n    const safeCeils = state.ceils\n      .filter(ceil => ceil.state !== 'open')\n      .filter(ceil => ceil.minesAround >= 0);\n    return safeCeils.length;\n  }\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEIL', payload: index });\n  }\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEILS', payload: index });\n  }\n  return (\n    <MinesweeperView\n      {...state}\n      onClose={onClose}\n      changeCeilState={changeCeilState}\n      openCeil={openCeil}\n      openCeils={openCeils}\n      onReset={onReset}\n      seconds={seconds}\n      openingCeil={openingCeil}\n      openingCeils={openingCeils}\n    />\n  );\n}\n\nfunction genGameConfig(config) {\n  const { rows, columns, mines } = config;\n  const ceils = Array(rows * columns)\n    .fill()\n    .map(_ => ({\n      state: 'cover',\n      minesAround: 0,\n      opening: false,\n    }));\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction insertMines(config, originCeils) {\n  const { rows, columns, mines, exclude } = config;\n  const ceils = originCeils.map(ceil => ({ ...ceil }));\n  if (rows * columns !== ceils.length)\n    throw new Error('rows and columns not equal to ceils');\n  const indexArray = [...Array(rows * columns).keys()];\n  sampleSize(\n    indexArray.filter(i => i !== exclude),\n    mines,\n  ).forEach(chosen => {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(nearIndex => {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction autoCeils(state, index) {\n  const { rows, columns } = state;\n  const ceils = state.ceils.map(ceil => ({\n    ...ceil,\n    walked: false,\n  }));\n  return walkCeils(index);\n  function walkCeils(index) {\n    const ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [\n      index,\n      ...getNearIndexes(index, rows, columns).reduce(\n        (lastIndexes, ceilIndex) => {\n          return [...lastIndexes, ...walkCeils(ceilIndex)];\n        },\n        [],\n      ),\n    ];\n  }\n}\n\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  const row = Math.floor(index / columns);\n  const column = index % columns;\n  return [\n    index - columns - 1,\n    index - columns,\n    index - columns + 1,\n    index - 1,\n    index + 1,\n    index + columns - 1,\n    index + columns,\n    index + columns + 1,\n  ].filter((_, arrayIndex) => {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\n\nfunction useTimer(status) {\n  const [seconds, setSeconds] = useState(0);\n  function addSecond() {\n    setSeconds(sec => sec + 1);\n  }\n  useEffect(() => {\n    let timer;\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n      case 'new':\n        setSeconds(0);\n        break;\n      default:\n        break;\n    }\n    return () => clearInterval(timer);\n  }, [status]);\n  return seconds;\n}\n\nexport default MineSweeper;\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC9D,OAAOC,UAAU,MAAM,mBAAmB;AAE1C,SAASC,MAAM,QAAQ,UAAU;AACjC,OAAOC,eAAe,MAAM,mBAAmB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAEA,SAASC,YAAYA,CAAA,EAA0B;EAAA,IAAzBC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,UAAU;EAC3C,OAAO;IACLD,UAAU;IACVI,MAAM,EAAE,KAAK;IACb,GAAGC,aAAa,CAACV,MAAM,CAACK,UAAU,CAAC;EACrC,CAAC;AACH;AAEA,SAASM,OAAOA,CAACC,KAAK,EAAe;EAAA,IAAbC,MAAM,GAAAP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACjC,QAAQO,MAAM,CAACC,IAAI;IACjB,KAAK,WAAW;MACd,MAAMT,UAAU,GAAGQ,MAAM,CAACE,OAAO,IAAIH,KAAK,CAACP,UAAU;MACrD,OAAOD,YAAY,CAACC,UAAU,CAAC;IACjC,KAAK,YAAY;MACf,MAAMW,OAAO,GAAGH,MAAM,CAACE,OAAO;MAC9B,OAAO;QACL,GAAGH,KAAK;QACR,GAAGK,WAAW,CAAC;UAAE,GAAGjB,MAAM,CAACY,KAAK,CAACP,UAAU,CAAC;UAAEW;QAAQ,CAAC,EAAEJ,KAAK,CAACM,KAAK,CAAC;QACrET,MAAM,EAAE;MACV,CAAC;IACH,KAAK,WAAW;MAAE;QAChB,MAAMU,OAAO,GAAGC,SAAS,CAACR,KAAK,EAAEC,MAAM,CAACE,OAAO,CAAC;QAChD,MAAMG,KAAK,GAAG,CAAC,GAAGN,KAAK,CAACM,KAAK,CAAC;QAC9BC,OAAO,CAACE,OAAO,CAACC,CAAC,IAAI;UACnB,MAAMC,IAAI,GAAGL,KAAK,CAACI,CAAC,CAAC;UACrBJ,KAAK,CAACI,CAAC,CAAC,GAAG;YAAE,GAAGC,IAAI;YAAEX,KAAK,EAAE;UAAO,CAAC;QACvC,CAAC,CAAC;QACF,OAAO;UACL,GAAGA,KAAK;UACRM;QACF,CAAC;MACH;IACA,KAAK,mBAAmB;MAAE;QACxB,MAAMM,KAAK,GAAGX,MAAM,CAACE,OAAO;QAC5B,MAAMG,KAAK,GAAG,CAAC,GAAGN,KAAK,CAACM,KAAK,CAAC;QAC9B,MAAMK,IAAI,GAAGX,KAAK,CAACM,KAAK,CAACM,KAAK,CAAC;QAC/B,IAAIC,QAAQ;QACZ,QAAQF,IAAI,CAACX,KAAK;UAChB,KAAK,OAAO;YACVa,QAAQ,GAAG,MAAM;YACjB;UACF,KAAK,MAAM;YACTA,QAAQ,GAAG,SAAS;YACpB;UACF,KAAK,SAAS;YACZA,QAAQ,GAAG,OAAO;YAClB;UACF;YACE,MAAM,IAAIC,KAAK,CAAC,sBAAsBH,IAAI,CAACX,KAAK,EAAE,CAAC;QACvD;QACAM,KAAK,CAACM,KAAK,CAAC,GAAG;UAAE,GAAGD,IAAI;UAAEX,KAAK,EAAEa;QAAS,CAAC;QAC3C,OAAO;UACL,GAAGb,KAAK;UACRM;QACF,CAAC;MACH;IACA,KAAK,WAAW;MAAE;QAChB,MAAMA,KAAK,GAAGN,KAAK,CAACM,KAAK,CAACS,GAAG,CAACJ,IAAI,IAAI;UACpC,IAAIA,IAAI,CAACK,WAAW,GAAG,CAAC,IAAIL,IAAI,CAACX,KAAK,KAAK,MAAM,EAAE;YACjD,OAAO;cACL,GAAGW,IAAI;cACPX,KAAK,EAAE;YACT,CAAC;UACH,CAAC,MAAM,IAAIW,IAAI,CAACX,KAAK,KAAK,MAAM,IAAIW,IAAI,CAACK,WAAW,IAAI,CAAC,EAAE;YACzD,OAAO;cACL,GAAGL,IAAI;cACPX,KAAK,EAAE;YACT,CAAC;UACH,CAAC,MAAM;YACL,OAAO;cACL,GAAGW,IAAI;cACPM,OAAO,EAAE;YACX,CAAC;UACH;QACF,CAAC,CAAC;QACFX,KAAK,CAACL,MAAM,CAACE,OAAO,CAAC,CAACH,KAAK,GAAG,KAAK;QACnC,OAAO;UACL,GAAGA,KAAK;UACRH,MAAM,EAAE,MAAM;UACdS;QACF,CAAC;MACH;IACA,KAAK,KAAK;MAAE;QACV,MAAMA,KAAK,GAAGN,KAAK,CAACM,KAAK,CAACS,GAAG,CAACJ,IAAI,IAAI;UACpC,IAAIA,IAAI,CAACK,WAAW,IAAI,CAAC,EAAE;YACzB,OAAO;cACL,GAAGL,IAAI;cACPX,KAAK,EAAE;YACT,CAAC;UACH,CAAC,MAAM;YACL,OAAO;cACL,GAAGW,IAAI;cACPX,KAAK,EAAE;YACT,CAAC;UACH;QACF,CAAC,CAAC;QACF,OAAO;UACL,GAAGA,KAAK;UACRH,MAAM,EAAE,KAAK;UACbS;QACF,CAAC;MACH;IACA,KAAK,cAAc;MAAE;QACnB,MAAMK,IAAI,GAAGX,KAAK,CAACM,KAAK,CAACL,MAAM,CAACE,OAAO,CAAC;QACxC,MAAMG,KAAK,GAAGN,KAAK,CAACM,KAAK,CAACS,GAAG,CAACJ,IAAI,KAAK;UACrC,GAAGA,IAAI;UACPM,OAAO,EAAE;QACX,CAAC,CAAC,CAAC;QACHX,KAAK,CAACL,MAAM,CAACE,OAAO,CAAC,GAAG;UAAE,GAAGQ,IAAI;UAAEM,OAAO,EAAE;QAAK,CAAC;QAClD,OAAO;UACL,GAAGjB,KAAK;UACRM;QACF,CAAC;MACH;IACA,KAAK,eAAe;MAAE;QACpB,MAAMC,OAAO,GAAGW,cAAc,CAACjB,MAAM,CAACE,OAAO,EAAEH,KAAK,CAACmB,IAAI,EAAEnB,KAAK,CAACoB,OAAO,CAAC;QACzE,MAAMd,KAAK,GAAGN,KAAK,CAACM,KAAK,CAACS,GAAG,CAACJ,IAAI,KAAK;UACrC,GAAGA,IAAI;UACPM,OAAO,EAAE;QACX,CAAC,CAAC,CAAC;QACH,CAAC,GAAGV,OAAO,EAAEN,MAAM,CAACE,OAAO,CAAC,CAACM,OAAO,CAACG,KAAK,IAAI;UAC5C,MAAMD,IAAI,GAAG;YAAE,GAAGL,KAAK,CAACM,KAAK;UAAE,CAAC;UAChCD,IAAI,CAACM,OAAO,GAAG,IAAI;UACnBX,KAAK,CAACM,KAAK,CAAC,GAAGD,IAAI;QACrB,CAAC,CAAC;QACF,OAAO;UACL,GAAGX,KAAK;UACRM;QACF,CAAC;MACH;IACA;MACE,OAAON,KAAK;EAChB;AACF;AAEA,SAASqB,WAAWA,CAAAC,IAAA,EAAiC;EAAAC,EAAA;EAAA,IAAhC;IAAEC,iBAAiB;IAAEC;EAAQ,CAAC,GAAAH,IAAA;EACjD,MAAM,CAACtB,KAAK,EAAE0B,QAAQ,CAAC,GAAG1C,UAAU,CAClCe,OAAO,EACPP,YAAY,CAACgC,iBAAiB,CAChC,CAAC;EACD,MAAMG,OAAO,GAAGC,QAAQ,CAAC5B,KAAK,CAACH,MAAM,CAAC;EACtC,SAASgC,eAAeA,CAACjB,KAAK,EAAE;IAC9B,MAAMD,IAAI,GAAGX,KAAK,CAACM,KAAK,CAACM,KAAK,CAAC;IAC/B,IAAID,IAAI,CAACX,KAAK,KAAK,MAAM,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC8B,QAAQ,CAAC9B,KAAK,CAACH,MAAM,CAAC,EAAE;IACrE6B,QAAQ,CAAC;MAAExB,IAAI,EAAE,mBAAmB;MAAEC,OAAO,EAAES;IAAM,CAAC,CAAC;EACzD;EACA,SAASmB,QAAQA,CAACnB,KAAK,EAAE;IACvB,QAAQZ,KAAK,CAACH,MAAM;MAClB,KAAK,KAAK;QACR6B,QAAQ,CAAC;UAAExB,IAAI,EAAE,YAAY;UAAEC,OAAO,EAAES;QAAM,CAAC,CAAC;QAChDc,QAAQ,CAAC;UAAExB,IAAI,EAAE,WAAW;UAAEC,OAAO,EAAES;QAAM,CAAC,CAAC;QAC/C;MACF,KAAK,SAAS;QACZ,MAAMD,IAAI,GAAGX,KAAK,CAACM,KAAK,CAACM,KAAK,CAAC;QAC/B,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAACkB,QAAQ,CAACnB,IAAI,CAACX,KAAK,CAAC,EAAE;UACzC;QACF,CAAC,MAAM,IAAIW,IAAI,CAACK,WAAW,GAAG,CAAC,EAAE;UAC/BU,QAAQ,CAAC;YAAExB,IAAI,EAAE,WAAW;YAAEC,OAAO,EAAES;UAAM,CAAC,CAAC;QACjD,CAAC,MAAM;UACLc,QAAQ,CAAC;YAAExB,IAAI,EAAE,WAAW;YAAEC,OAAO,EAAES;UAAM,CAAC,CAAC;QACjD;QACA;MACF;MACA;IACF;EACF;EACA,SAASoB,SAASA,CAACpB,KAAK,EAAE;IACxB,MAAMD,IAAI,GAAGX,KAAK,CAACM,KAAK,CAACM,KAAK,CAAC;IAC/B,IACED,IAAI,CAACX,KAAK,KAAK,MAAM,IACrBW,IAAI,CAACK,WAAW,IAAI,CAAC,IACrBhB,KAAK,CAACH,MAAM,KAAK,SAAS,EAE1B;IACF,MAAMU,OAAO,GAAGW,cAAc,CAACN,KAAK,EAAEZ,KAAK,CAACmB,IAAI,EAAEnB,KAAK,CAACoB,OAAO,CAAC;IAChE,MAAMa,SAAS,GAAG1B,OAAO,CAACQ,GAAG,CAACL,CAAC,IAAIV,KAAK,CAACM,KAAK,CAACI,CAAC,CAAC,CAAC;IAClD,IACEuB,SAAS,CAACC,MAAM,CAACvB,IAAI,IAAIA,IAAI,CAACX,KAAK,KAAK,MAAM,CAAC,CAACL,MAAM,KACtDgB,IAAI,CAACK,WAAW,EAEhB;IACF,MAAMmB,SAAS,GAAG5B,OAAO,CAAC6B,IAAI,CAC5B1B,CAAC,IAAIV,KAAK,CAACM,KAAK,CAACI,CAAC,CAAC,CAACM,WAAW,GAAG,CAAC,IAAIhB,KAAK,CAACM,KAAK,CAACI,CAAC,CAAC,CAACV,KAAK,KAAK,MAClE,CAAC;IACD,IAAImC,SAAS,EAAE;MACbT,QAAQ,CAAC;QAAExB,IAAI,EAAE,WAAW;QAAEC,OAAO,EAAEgC;MAAU,CAAC,CAAC;IACrD,CAAC,MAAM;MACL5B,OAAO,CAACE,OAAO,CAACC,CAAC,IAAIgB,QAAQ,CAAC;QAAExB,IAAI,EAAE,WAAW;QAAEC,OAAO,EAAEO;MAAE,CAAC,CAAC,CAAC;IACnE;EACF;EACAzB,SAAS,CAAC,MAAM;IACd,IAAIe,KAAK,CAACH,MAAM,KAAK,SAAS,IAAIwC,YAAY,CAAC,CAAC,KAAK,CAAC,EAAE;MACtDX,QAAQ,CAAC;QAAExB,IAAI,EAAE;MAAM,CAAC,CAAC;IAC3B;EACF,CAAC,CAAC;EACF,SAASoC,OAAOA,CAAC7C,UAAU,EAAE;IAC3BiC,QAAQ,CAAC;MAAExB,IAAI,EAAE,WAAW;MAAEC,OAAO,EAAEV;IAAW,CAAC,CAAC;EACtD;EACA,SAAS4C,YAAYA,CAAA,EAAG;IACtB,MAAME,SAAS,GAAGvC,KAAK,CAACM,KAAK,CAC1B4B,MAAM,CAACvB,IAAI,IAAIA,IAAI,CAACX,KAAK,KAAK,MAAM,CAAC,CACrCkC,MAAM,CAACvB,IAAI,IAAIA,IAAI,CAACK,WAAW,IAAI,CAAC,CAAC;IACxC,OAAOuB,SAAS,CAAC5C,MAAM;EACzB;EACA,SAAS6C,WAAWA,CAAC5B,KAAK,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAACkB,QAAQ,CAAC9B,KAAK,CAACH,MAAM,CAAC,EAAE;IAC5C6B,QAAQ,CAAC;MAAExB,IAAI,EAAE,cAAc;MAAEC,OAAO,EAAES;IAAM,CAAC,CAAC;EACpD;EACA,SAAS6B,YAAYA,CAAC7B,KAAK,EAAE;IAC3B,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAACkB,QAAQ,CAAC9B,KAAK,CAACH,MAAM,CAAC,EAAE;IAC5C6B,QAAQ,CAAC;MAAExB,IAAI,EAAE,eAAe;MAAEC,OAAO,EAAES;IAAM,CAAC,CAAC;EACrD;EACA,oBACErB,OAAA,CAACF,eAAe;IAAA,GACVW,KAAK;IACTyB,OAAO,EAAEA,OAAQ;IACjBI,eAAe,EAAEA,eAAgB;IACjCE,QAAQ,EAAEA,QAAS;IACnBC,SAAS,EAAEA,SAAU;IACrBM,OAAO,EAAEA,OAAQ;IACjBX,OAAO,EAAEA,OAAQ;IACjBa,WAAW,EAAEA,WAAY;IACzBC,YAAY,EAAEA;EAAa;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC5B,CAAC;AAEN;AAACtB,EAAA,CA1FQF,WAAW;EAAA,QAKFO,QAAQ;AAAA;AAAAkB,EAAA,GALjBzB,WAAW;AA4FpB,SAASvB,aAAaA,CAACiD,MAAM,EAAE;EAC7B,MAAM;IAAE5B,IAAI;IAAEC,OAAO;IAAE4B;EAAM,CAAC,GAAGD,MAAM;EACvC,MAAMzC,KAAK,GAAG2C,KAAK,CAAC9B,IAAI,GAAGC,OAAO,CAAC,CAChC8B,IAAI,CAAC,CAAC,CACNnC,GAAG,CAACoC,CAAC,KAAK;IACTnD,KAAK,EAAE,OAAO;IACdgB,WAAW,EAAE,CAAC;IACdC,OAAO,EAAE;EACX,CAAC,CAAC,CAAC;EACL,OAAO;IACLE,IAAI;IACJC,OAAO;IACPd,KAAK;IACL0C;EACF,CAAC;AACH;AAEA,SAAS3C,WAAWA,CAAC0C,MAAM,EAAEK,WAAW,EAAE;EACxC,MAAM;IAAEjC,IAAI;IAAEC,OAAO;IAAE4B,KAAK;IAAE5C;EAAQ,CAAC,GAAG2C,MAAM;EAChD,MAAMzC,KAAK,GAAG8C,WAAW,CAACrC,GAAG,CAACJ,IAAI,KAAK;IAAE,GAAGA;EAAK,CAAC,CAAC,CAAC;EACpD,IAAIQ,IAAI,GAAGC,OAAO,KAAKd,KAAK,CAACX,MAAM,EACjC,MAAM,IAAImB,KAAK,CAAC,qCAAqC,CAAC;EACxD,MAAMuC,UAAU,GAAG,CAAC,GAAGJ,KAAK,CAAC9B,IAAI,GAAGC,OAAO,CAAC,CAACkC,IAAI,CAAC,CAAC,CAAC;EACpDnE,UAAU,CACRkE,UAAU,CAACnB,MAAM,CAACxB,CAAC,IAAIA,CAAC,KAAKN,OAAO,CAAC,EACrC4C,KACF,CAAC,CAACvC,OAAO,CAAC8C,MAAM,IAAI;IAClBjD,KAAK,CAACiD,MAAM,CAAC,CAACvC,WAAW,GAAG,CAAC,EAAE;IAC/BE,cAAc,CAACqC,MAAM,EAAEpC,IAAI,EAAEC,OAAO,CAAC,CAACX,OAAO,CAAC+C,SAAS,IAAI;MACzDlD,KAAK,CAACkD,SAAS,CAAC,CAACxC,WAAW,IAAI,CAAC;IACnC,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAO;IACLG,IAAI;IACJC,OAAO;IACPd,KAAK;IACL0C;EACF,CAAC;AACH;AAEA,SAASxC,SAASA,CAACR,KAAK,EAAEY,KAAK,EAAE;EAC/B,MAAM;IAAEO,IAAI;IAAEC;EAAQ,CAAC,GAAGpB,KAAK;EAC/B,MAAMM,KAAK,GAAGN,KAAK,CAACM,KAAK,CAACS,GAAG,CAACJ,IAAI,KAAK;IACrC,GAAGA,IAAI;IACP8C,MAAM,EAAE;EACV,CAAC,CAAC,CAAC;EACH,OAAOC,SAAS,CAAC9C,KAAK,CAAC;EACvB,SAAS8C,SAASA,CAAC9C,KAAK,EAAE;IACxB,MAAMD,IAAI,GAAGL,KAAK,CAACM,KAAK,CAAC;IACzB,IAAID,IAAI,CAAC8C,MAAM,IAAI9C,IAAI,CAACK,WAAW,GAAG,CAAC,IAAIL,IAAI,CAACX,KAAK,KAAK,MAAM,EAAE,OAAO,EAAE;IAC3EW,IAAI,CAAC8C,MAAM,GAAG,IAAI;IAClB,IAAI9C,IAAI,CAACK,WAAW,GAAG,CAAC,EAAE,OAAO,CAACJ,KAAK,CAAC;IACxC,OAAO,CACLA,KAAK,EACL,GAAGM,cAAc,CAACN,KAAK,EAAEO,IAAI,EAAEC,OAAO,CAAC,CAACuC,MAAM,CAC5C,CAACC,WAAW,EAAEC,SAAS,KAAK;MAC1B,OAAO,CAAC,GAAGD,WAAW,EAAE,GAAGF,SAAS,CAACG,SAAS,CAAC,CAAC;IAClD,CAAC,EACD,EACF,CAAC,CACF;EACH;AACF;AAEA,SAAS3C,cAAcA,CAACN,KAAK,EAAEO,IAAI,EAAEC,OAAO,EAAE;EAC5C,IAAIR,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAIO,IAAI,GAAGC,OAAO,EAAE,OAAO,EAAE;EACnD,MAAM0C,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACpD,KAAK,GAAGQ,OAAO,CAAC;EACvC,MAAM6C,MAAM,GAAGrD,KAAK,GAAGQ,OAAO;EAC9B,OAAO,CACLR,KAAK,GAAGQ,OAAO,GAAG,CAAC,EACnBR,KAAK,GAAGQ,OAAO,EACfR,KAAK,GAAGQ,OAAO,GAAG,CAAC,EACnBR,KAAK,GAAG,CAAC,EACTA,KAAK,GAAG,CAAC,EACTA,KAAK,GAAGQ,OAAO,GAAG,CAAC,EACnBR,KAAK,GAAGQ,OAAO,EACfR,KAAK,GAAGQ,OAAO,GAAG,CAAC,CACpB,CAACc,MAAM,CAAC,CAACiB,CAAC,EAAEe,UAAU,KAAK;IAC1B,IAAIJ,GAAG,KAAK,CAAC,IAAII,UAAU,GAAG,CAAC,EAAE,OAAO,KAAK;IAC7C,IAAIJ,GAAG,KAAK3C,IAAI,GAAG,CAAC,IAAI+C,UAAU,GAAG,CAAC,EAAE,OAAO,KAAK;IACpD,IAAID,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACnC,QAAQ,CAACoC,UAAU,CAAC,EAAE,OAAO,KAAK;IAChE,IAAID,MAAM,KAAK7C,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACU,QAAQ,CAACoC,UAAU,CAAC,EAAE,OAAO,KAAK;IAC1E,OAAO,IAAI;EACb,CAAC,CAAC;AACJ;AAEA,SAAStC,QAAQA,CAAC/B,MAAM,EAAE;EAAAsE,GAAA;EACxB,MAAM,CAACxC,OAAO,EAAEyC,UAAU,CAAC,GAAGlF,QAAQ,CAAC,CAAC,CAAC;EACzC,SAASmF,SAASA,CAAA,EAAG;IACnBD,UAAU,CAACE,GAAG,IAAIA,GAAG,GAAG,CAAC,CAAC;EAC5B;EACArF,SAAS,CAAC,MAAM;IACd,IAAIsF,KAAK;IACT,QAAQ1E,MAAM;MACZ,KAAK,SAAS;QACZ0E,KAAK,GAAGC,WAAW,CAACH,SAAS,EAAE,IAAI,CAAC;QACpC;MACF,KAAK,KAAK;QACRD,UAAU,CAAC,CAAC,CAAC;QACb;MACF;QACE;IACJ;IACA,OAAO,MAAMK,aAAa,CAACF,KAAK,CAAC;EACnC,CAAC,EAAE,CAAC1E,MAAM,CAAC,CAAC;EACZ,OAAO8B,OAAO;AAChB;AAACwC,GAAA,CApBQvC,QAAQ;AAsBjB,eAAeP,WAAW;AAAC,IAAAyB,EAAA;AAAA4B,YAAA,CAAA5B,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}